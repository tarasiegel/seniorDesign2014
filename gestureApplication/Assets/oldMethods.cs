// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;

namespace AssemblyCSharp
{
		public class oldMethods
		{
				public oldMethods ()
				{
				}


/*class PathRenderer {
	LineRenderer lineRenderer;
	
	// passage points
	List<Vector3> points = new List<Vector3>();
	
	// list of marker objects currently instantiated
	List<GameObject> markers = new List<GameObject>();
	
	public PathRenderer( int index, LineRenderer lineRendererPrefab ) {
		lineRenderer = Instantiate( lineRendererPrefab ) as LineRenderer;
		lineRenderer.name = lineRendererPrefab.name + index;
		lineRenderer.enabled = true;	
		UpdateLines();
	}
	
	public void Reset() {
		points.Clear();
		UpdateLines();
		foreach (GameObject marker in markers) {
			Destroy (marker);
		}
		markers.Clear();
	}
	
	public void AddPoint( Vector2 screenPos ) {
		AddPoint( screenPos, null );
	}
	
	public void AddPoint( Vector2 screenPos, GameObject markerPrefab ) {
		Vector3 pos = gestureBase.GetWorldPos (screenPos);
		
		if( markerPrefab )
			AddMarker( pos, markerPrefab );
		
		points.Add( pos );
		UpdateLines();
	}
	
	GameObject AddMarker( Vector2 pos, GameObject prefab ) {
		GameObject instance = Instantiate( prefab, pos, Quaternion.identity ) as GameObject;
		instance.name = prefab.name + "(" + markers.Count + ")";
		markers.Add( instance );
		return instance;
	}
	
	void UpdateLines() {
		lineRenderer.SetVertexCount( points.Count );
		for( int i = 0; i < points.Count; ++i )
			lineRenderer.SetPosition( i, points[i] );
	}
}

PathRenderer[] paths;

		// Update is called once per frame
		void Update () {
			//base.Start();
			/*paths = new PathRenderer[FingerGestures.Instance.MaxFingers];
		for (int i = 0; i < paths.Length; ++i) {
			paths [i] = new PathRenderer (i, lineRendererPrefab);
		}
		}
		
		
		//The limits are the one imposed by the platform/device you run the app on.  
		//Swipes can be detected "per-finger" via the OnFingerSwipe event (or TBSwipe 
		//toolbox script). This allows you to detect multiple swipes at once, using the
		//"fingerIndex" value to identify which finger performed the gesture.
		void OnSwipe( SwipeGesture gesture ) {
			//FingerGestures.SwipeDirection direction = gesture.Direction;
			//UI.StatusText = "Swiped " + direction + " with finger " + gesture.Fingers[0];
			//gestureTracker.updateList (gesture);
			//UI.StatusText = gestureTracker.printOutCurrentPath();
			
		}
		
		void OnLongPress(LongPressGesture gesture) {
			//UI.StatusText = "Long Press with finger " + gesture.Fingers[0] + " at: " + gesture.Position;
			//SpawnParticles (gesture);
			//gestureTracker.updateList (gesture);
			//UI.StatusText = gestureTracker.printOutCurrentPath();}
		
		
		
		
		//NOT CURRENTLY BEING USED METHODS
		
		void OnTap( TapGesture gesture ) {
			//UI.StatusText = "Tapped with finger " + gesture.Fingers[0] + " at: " + gesture.Position;
			//gestureTracker.updateList (gesture);
			//UI.StatusText = gestureTracker.printOutCurrentPath();}
		
		/*void SpawnParticles(LongPressGesture obj) {
		//ParticleSystem.Particle particle = new ParticleSystem.Particle ();
		//emitter.transform.position = obj.Position;
		//particle.position = obj.Position;
		//emitter.Emit (particle);
		//emitter.particleSystem.Play ();
		Vector3 pos = new Vector3 (obj.Position.x, obj.Position.y);
		GameObject emit = Instantiate (emitter, pos, Quaternion.identity) as GameObject;
		ParticleSystem p = emit.GetComponent<ParticleSystem> ();
		//p.Play ();
	}*/
		
		/*void OnFingerDown( FingerDownEvent e ) {
		PathRenderer path = paths[e.Finger.Index];
		path.Reset();
		path.AddPoint( e.Finger.Position, fingerDownMarkerPrefab );
	}*/
		
		/*void OnFingerMove( FingerMotionEvent e ) {
		PathRenderer path = paths[e.Finger.Index];
		
		if( e.Phase == FingerMotionPhase.Started )
		{
			UI.StatusText = "Started moving " + e.Finger;
			path.AddPoint( e.Position, fingerMoveBeginMarkerPrefab );
		}
		else if( e.Phase == FingerMotionPhase.Updated )
		{
			path.AddPoint( e.Position );
		}
		else
		{
			UI.StatusText = "Stopped moving " + e.Finger;
			path.AddPoint( e.Position, fingerMoveEndMarkerPrefab );
		}
	}*/
		
		/*void OnFingerUp( FingerUpEvent e ) {
		PathRenderer path = paths[e.Finger.Index];
		path.AddPoint( e.Finger.Position, fingerUpMarkerPrefab );
		UI.StatusText = "Finger " + e.Finger + " was held down for " + e.TimeHeldDown.ToString( "N2" ) + " seconds";
		gestureTracker.updateList (path);
	}*/


	}
}